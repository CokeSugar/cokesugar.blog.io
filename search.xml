<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS动画之CAKeyframeAnimation]]></title>
    <url>%2F2017%2F12%2F27%2F20171227-iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCAKeyframeAnimation%2F</url>
    <content type="text"><![CDATA[1.CAKeyframeAnimation介绍CABasicAnimation和CAKeyFrameAnimation都是CAPropertyAnimation的子类，CABasicAnimation算是CAKeyFrameAnimation的 特殊情况。CAKeyFrameAnimation支持关键帧的属性动画，可以通过values属性指定多个关键帧，通过关键帧可以指定动画的各阶段的关键值]]></content>
      <tags>
        <tag>CAKeyframeAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画之CABasicAnimation]]></title>
    <url>%2F2017%2F12%2F27%2F20171227-iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCABasicAnimation%2F</url>
    <content type="text"><![CDATA[1.CABaseAnimation介绍CABaseAnimation介绍 是 CAPropertyAnimation的子类，简单控制CALayer层的属性慢慢改变，从而实现动画效果。使用方法animationWithKeyPath:对 CABasicAnimation进行实例化，并指定Layer的属性作为关键路径进行注册。例如： 1CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;]; 相关属性和声明属性 | 说明—|—duration | 动画时长repeatCount | 重复次数。不停重复设置为 HUGE_VALFbeginTime | 指定动画开始的时间。从开始延迟几秒的话，设置为[CACurren|tMediaTime() + 秒数] 的方式timingFunction | 动画的速度变化autoreverses | 动画结束时是否执行逆动画fromValue | 起始值toValue | 结束值byValue | 结束值（相对值） 一些常用的animationWithKeyPath值 值 说明 使用形式 transform.scale 比例转化 @(0.8) transform.scale.x 宽的比例 @(0.8) transform.scale.y 高的比例 @(0.8) transform.rotation.x 围绕x轴旋转 @(M_PI) transform.rotation.y 围绕y轴旋转 @(M_PI) transform.rotation.z 围绕z轴旋转 @(M_PI) cornerRadius 圆角的设置 @(50) backgroundColor 背景颜色的变化 (id)[UIColor purpleColor].CGColor bounds 大小，中心不变 [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)]; position 位置(中心点的改变) [NSValue valueWithCGPoint:CGPointMake(300, 300)]; contents 内容，比如UIImageView的图片 imageAnima.toValue = (id)[UIImage imageNamed:@”to”].CGImage; opacity 透明度 @(0.7) contentsRect.size.width 横向拉伸缩放 @(0.4)最好是0~1之间的 2.CABasicAnimation的使用示例 2.1.移动动画 123456CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];anima.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-75)];anima.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-75)];anima.duration = 1.0f;anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];[_demoView.layer addAnimation:anima forKey:@&quot;positionAnimation&quot;]; 2.2.透明度动画 12345CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];anima.fromValue = [NSNumber numberWithFloat:1.0f];anima.toValue = [NSNumber numberWithFloat:0.2f];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;opacityAniamtion&quot;]; 2.3.缩放动画 123456789CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;];anima.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 100)];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;];// CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];//同上// anima.toValue = [NSNumber numberWithFloat:2.0f];// anima.duration = 1.0f;// [_demoView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;]; 2.4.旋转动画 1234567891011CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];//绕着z轴为矢量，进行旋转(@&quot;transform.rotation.z&quot;==@@&quot;transform.rotation&quot;)anima.toValue = [NSNumber numberWithFloat:M_PI];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;rotateAnimation&quot;];// //valueWithCATransform3D作用与layer// CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];// anima.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI, 0, 0, 1)];//绕着矢量（x,y,z）旋转// anima.duration = 1.0f;// //anima.repeatCount = MAXFLOAT;// [_demoView.layer addAnimation:anima forKey:@&quot;rotateAnimation&quot;]; 2.5.背景色动画 1234CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];anima.toValue =(id) [UIColor greenColor].CGColor;anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;backgroundAnimation&quot;];]]></content>
      <tags>
        <tag>CABasicAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block引用计数问题]]></title>
    <url>%2F2017%2F12%2F26%2F20171226-Block%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在学习block，在网上看到一个关于block和引用计数的问题:Block 捕获对象类型的变量时的问题123456789typedef void(^Block)();Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数%d&quot;, _objc_rootRetainCount(person));Block block = ^&#123; perons.name = @&quot;Nature&quot;; NSLog(@&quot;Block中person的引用计数%d&quot;, _objc_rootRetainCount(person));&#125;;block();NSLog(@&quot;Block后person的引用计数%d&quot;, _objc_rootRetainCount(person)); 在ARC下运行结果为： 123Block前person的引用计数为1Block中person的引用计数为3Block后person的引用计数为3 为什么block截获person变量后，引用计数会+2？接下来修改了代码，输出person的地址信息 12345678typedef void(^Block)(void);Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));Block block =^&#123; NSLog(@&quot;Block中person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));&#125;;block();NSLog(@&quot;Block后person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person)); 我在MRC 下运行代码，结果为：123Block前person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff628 -0x100547c20Block中person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff618 -0x100547c20Block后person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff628 -0x100547c20 其中 Person: 0x100547c20 为 person 对象信息0x7ffeefbff628 0x7ffeefbff618 为栈上指针，存放的数据是地址0x100547c200x100547c20 为堆上存放person的地址。 从MRC运行结果可以看出 MRC 下，block 内引用person 只复制了一个指针。 我多次运行 发现两个栈指针的差值是固定的，一直都是0x10（不太了解为什么差值一直一样，中间的地址存放的是什么数据）。接下来我在ARC下尝试着将person 的地址减去一个 0x10 , 将新地址的内容输出来。 12345678typedef void(^Block)(void);Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));Block block =^&#123; NSLog(@&quot;Block中person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));&#125;;block();NSLog(@&quot;Block后person的引用计数-%tu -%@ -%p -%p %p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person),(&amp;person-2),*(&amp;person-2)); 运行结果为：123Block前person的引用计数-1 -&lt;Person: 0x1004002b0&gt; -0x7ffeefbff620 -0x1004002b0Block中person的引用计数-3 -&lt;Person: 0x1004002b0&gt; -0x1007114c0 -0x1004002b0Block后person的引用计数-3 -&lt;Person: 0x1004002b0&gt; -0x7ffeefbff620 -0x1004002b0 0x7ffeefbff610 -0x1004002b0 我们发现在ARC下 栈指针 0x7ffeefbff610 和 0x7ffeefbff620 中的存放的数据都是person的地址 0x1004002b0。而在 堆地址0x1007114c0 也引用一份person。所以person的引用计数为3。 所以在ARC模式下，如果block 引用局部变量，先将变量地址复制到栈上，在从栈上复制到堆上。（不知道对不对啊）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString与TaggedPoint技术]]></title>
    <url>%2F2017%2F12%2F26%2F20171226-NSString%E4%B8%8ETaggedPoint%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1.问题在学习iOS中的NSString时，看到了掘金上的一篇文章 一个毫无道理的iOS问题1234567891011121314151617181920212223242526272829303132@interface ViewController ()@property (nonatomic, strong) NSString *string1;@property (nonatomic, assign) NSString *string2;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;1.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1&quot;]; self.string2 = self.string1; self.string1 = nil; NSLog(@&quot;string2 = %@&quot;,self.string2); NSLog(@&quot;2.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1234&quot;]; self.string2 = self.string1; self.string1 = nil; NSLog(@&quot;string2 = %@&quot;,self.string2);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 提问：第16行和第22行的执行结果分别是什么？测试后发现这段代码的问题是这样的:1.第16行执行后并不会崩溃，第22行执行后会崩溃2.只有字符串的内容长度超过10字节才会奔溃崩溃 2.解释我们修改代码查看两种情况下string1和string2的指针地址已经指针所存储的数据。 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;1.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;SSS&quot;]; self.string2 = self.string1; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); self.string1 = nil; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); NSLog(@&quot;string2 = %@&quot;,self.string2); NSLog(@&quot;\n\n&quot;); NSLog(@&quot;2.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1234&quot;]; self.string2 = self.string1; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); self.string1 = nil; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); NSLog(@&quot;string2 = %@&quot;,self.string2);&#125; 运行时第22行出现异常，我们先看一下第一种情况的打印信息。 1234561.-------string1 = 0xa000000005353533 0x15dd39540 SSS NSTaggedPointerStringstring2 = 0xa000000005353533 0x15dd39548 SSS NSTaggedPointerStringstring1 = 0x0 0x15dd39540 (null) (null)string2 = 0xa000000005353533 0x15dd39548 SSS NSTaggedPointerStringstring2 = SSS 可以看出0x15dd39540和0x15dd39548是两个堆指针，指针存储的数据是0xa000000005353533，可以看出0xa000000005353533不是一个有效地址，这是因为iOS使用了TaggedPoint技术，此时“SSS”这个字符串并不是存储在堆上，而是存储在self.string这个指针里面，self.string2=self.string1，完全就是一个赋值操作，不存在指向堆内存的问题，所以不会出现异常。关于TaggedPoint的详细介绍，给大家推荐一篇博客：深入理解Tagged Pointer 接下来我们看一下第二种情况的打印信息。 12342.-------string1 = 0x15de0f460 0x15dd39540 string1234 __NSCFStringstring2 = 0x15de0f460 0x15dd39548 string1234 __NSCFStringstring1 = 0x0 0x15dd39540 (null) (null) 从运行结果可以看出，0x15dd39540和0x15dd39548是两个堆指针，里面存的数据都是0x15de0f460，也是一个有效的堆地址，在self.string1=nil之后，0x15dd39540指向的内存区0x15de0f460已经被释放，再用self.string2来访问，0x15dd39548所执向的0x15de0f460已经不存在了，是一个野指针了，所以会野指针crash。 3.参考博客http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>TaggedPoint</tag>
      </tags>
  </entry>
</search>
