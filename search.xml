<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[在有了自动合成属性实例变量之后,@synthesize还有哪些使用场景？]]></title>
    <url>%2F2018%2F01%2F12%2F20180112-%E5%9C%A8%E6%9C%89%E4%BA%86%E8%87%AA%E5%8A%A8%E5%90%88%E6%88%90%E5%B1%9E%E6%80%A7%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E4%B9%8B%E5%90%8E-synthesize%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[转自：https://github.com/ChenYilong/iOSInterviewQuestions/tree/master/01%E3%80%8A%E6%8B%9B%E8%81%98%E4%B8%80%E4%B8%AA%E9%9D%A0%E8%B0%B1%E7%9A%84iOS%E3%80%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%82%E8%80%83%E7%AD%94%E6%A1%88 回答这个问题前，我们要搞清楚一个问题，什么情况下不会autosynthesis（自动合成）？ 同时重写了 setter 和 getter 时重写了只读属性的 getter 时使用了 @dynamic 时在 @protocol 中定义的所有属性在 category 中定义的所有属性重载的属性当你在子类中重载了父类中的属性，你必须 使用 @synthesize 来手动合成ivar。 除了后三条，对其他几个我们可以总结出一个规律：当你想手动管理 @property 的所有内容时，你就会尝试通过实现 @property 的所有“存取方法”（the accessor methods）或者使用 @dynamic 来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis（自动合成）。 因为有了 autosynthesis（自动合成），大部分开发者已经习惯不去手动定义ivar，而是依赖于 autosynthesis（自动合成），但是一旦你需要使用ivar，而 autosynthesis（自动合成）又失效了，如果不去手动定义ivar，那么你就得借助 @synthesize 来手动合成 ivar。 其实，@synthesize 语法还有一个应用场景，但是不太建议大家使用： 可以在类的实现代码里通过 @synthesize 语法来指定实例变量的名字: 1234@implementation CYLPerson@synthesize firstName = _myFirstName;@synthesize lastName = _myLastName;@end 上述语法会将生成的实例变量命名为 _myFirstName 与 _myLastName，而不再使用默认的名字。一般情况下无须修改默认的实例变量名，但是如果你不喜欢以下划线来命名实例变量，那么可以用这个办法将其改为自己想要的名字。笔者还是推荐使用默认的命名方案，因为如果所有人都坚持这套方案，那么写出来的代码大家都能看得懂。 举例说明：应用场景： 123456789101112131415161718192021222324252627282930313233343536//// .m文件// http://weibo.com/luohanchenyilong/ (微博@iOS程序犭袁)// https://github.com/ChenYilong// 打开第14行和第17行中任意一行，就可编译成功@import Foundation;@interface CYLObject : NSObject@property (nonatomic, copy) NSString *title;@end@implementation CYLObject &#123;// NSString *_title;&#125;//@synthesize title = _title;- (instancetype)init&#123;self = [super init];if (self) &#123;_title = @&quot;微博@iOS程序犭袁&quot;;&#125;return self;&#125;- (NSString *)title &#123;return _title;&#125;- (void)setTitle:(NSString *)title &#123;_title = [title copy];&#125;@end 当你同时重写了 setter 和 getter 时，系统就不会生成 ivar（实例变量/成员变量）。这时候有两种选择： 要么如第14行：手动创建 ivar要么如第17行：使用@synthesize foo = _foo; ，关联 @property 与 ivar。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>synthesize</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中类的load和initialize方法]]></title>
    <url>%2F2018%2F01%2F10%2F20180110-Objective-C%E4%B8%AD%E7%B1%BB%E7%9A%84load%E5%92%8Cinitialize%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Objective-C中类的load和initialize方法load方法 原型如下 1+ (void)load load函数调用特点如下： 对于加入运行期系统中的每个类（class）及分类（category）来说，都会调用此方法，且只会调用一次。如果分类和其所属的类都调用了load方法，则先调用类里面的，再调用分类里的。 load方法并不像普通方法那样，它并不遵从继承规则。即如果某个类本身没有load方法，那么不管其超类是否实现load方法，系统都不会调用。 initialize方法 其原型如下： 1+ (void)initialize initialize函数的特点是： 对每个类来说，该方法会在程序首次使用该类前调用，且只调用一次。它是由运行期系统来调用的，绝不应该通过代码直接调用。 initialize方法与其他消息一样，如果某个类未实现它，而其超类实现了，就会运行超 load和initialize的区别 load和initialize之间的区别如下： initialize是”惰性调用的”，即只有当用到了相关的类时，才会调用。如果某个类一直都没有使用，则其initialize方法就一直不会运行。这也就是说，应用程序无须把每个类的initialize都执行一遍。这就与load不同，对于load来说，应用程序必须阻塞并等待所有类的load都执行完，才能继续。 initialize在运行期系统执行该方法时，是处于正常状态，因此从运行期系统完整度上来讲，此时可以安全使用并调用任意类中的任意方法。而且，运行期系统也能保证initialize方法一定会在“线程安全的环境（thread-safe environment）”中执行，这就是说，只有执行initialize的那个线程可以操作类或者类实例。其他线程都要先阻塞，等着initialize执行完。load方法的问题在于，执行该方法时，运行期系统处于“脆弱状态（fragile state）”。在执行子类的load方法之前，必定会执行所有超类的load方法。 https://www.cnblogs.com/ider/archive/2012/09/29/objective_c_load_vs_initialize.html http://blog.csdn.net/u014084081/article/details/48265453]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C中autorelease的释放时机]]></title>
    <url>%2F2018%2F01%2F09%2F20180109-Objective-c%E4%B8%ADautorelease%E7%9A%84%E9%87%8A%E6%94%BE%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[转自：https://www.cnblogs.com/goodyboy6/p/4462968.html Objective-C中autorelease的释放时机 如果你使用过MRC，autorelease这个关键字应该是太熟悉了，每次在我们生成一个新的对象返回时，都需要向这个对象发送autorelease消息，目的是为了延时释放创建的对象。那到底是在什么时候，这个对象会被释放呢？有什么方法可以更快的释放一个autorelease对象呢？ 咱们先来看一个现象： 123456789101112131415161718192021222324252627@property (weak, nonatomic) NSString *weakString;- (void)viewDidLoad &#123;[super viewDidLoad];// Do any additional setup after loading the view.NSString *hello = [[NSString alloc] initWithCString:&quot;it will be released at the end of current runloop&quot; encoding:NSUTF8StringEncoding];self.weakString = hello;NSLog(@&quot;%@ - %@&quot;, self.weakString, NSStringFromSelector(_cmd));&#125;- (void)viewWillAppear:(BOOL)animated&#123;[super viewWillAppear:animated];NSLog(@&quot;%@ - %@&quot;, self.weakString, NSStringFromSelector(_cmd));&#125;- (void)viewDidAppear:(BOOL)animated&#123;[super viewDidAppear:animated];NSLog(@&quot;%@ - %@&quot;, self.weakString, NSStringFromSelector(_cmd));dispatch_async(dispatch_get_main_queue(), ^&#123;NSLog(@&quot;-2--%@ - %@&quot;, self.weakString, NSStringFromSelector(_cmd));&#125;);&#125; 我们创建了一个viewDidLoad方法中创建了一个weak指针指向一个字符串，当代码执行到viewWillAppear:和viewDidAppear:时，我们依然可以打印出weak指针指向的字符串，当在viewDidAppear:中在下一个runloop中执行打印操作时，weak指针就指向nil了，why ？ 编译器在ARC环境下可能会帮我们把这条语句self.weakString = hello改成类似这样： self.weakString = [[hello retain] autorelease];当向hello发送autorelease消息时，hello将会被加入到当前的autorelease pool中，当autorelease pool release时，它会像pool中hello发送release消息，然后hello就被真正释放了。 可是看看我们的示例代码，我们并没有autorelease pool啊，我们知道app启动时main函数里面有一个autorelease pool，难道是这个autorelease pool被释放了？ 显然不可能，那可以肯定的说，系统隐式的帮我们创建了autorelease pool。 系统怎么知道我们要为我们创建autorelease pool的呢？ ++main函数启动后系统会创建一个main runloop，每个runloop系统都会分配一个autorelease pool，它将在app退出的时候释放app所占用的内存。当用户输入设备（如点击button、键盘按下）、网络链接(socket收到数据)、定期或时间延迟事件（NSTimer），还有异步回调(NSURLConnection的异步请求)等三类（sources、timers、observers）会将这个main runloop激活并产生一个autorelease pool，当runloop进入睡眠时，释放这个autorelease pool。++ 比如我们的demo里面，是一个cell点事件触发了一个页面切换，从点击cell点击激活runloop到新页面的viewDidAppear:结束后runloop进入休眠，这中间创建的autorelease pool就是那个把weakString释放的家伙。 参考资料： 1）http://www.cnblogs.com/whyandinside/p/3489951.html 2）https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>autorelease</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString stringwithFormat方式创建的NSString的引用计数问题]]></title>
    <url>%2F2018%2F01%2F09%2F20180109-NSString-stringwithFormat%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%9A%84NSString%E7%9A%84%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[123NSString *string = [[NSString alloc] initWithFormat:@&quot;Hello, World!&quot;];NSString *string1 = [NSString stringWithFormat:@&quot;Hello, World!&quot;];NSLog(@&quot;%tu-%tu\n\n&quot;,CFGetRetainCount((__bridge CFTypeRef)(string)) ,CFGetRetainCount((__bridge CFTypeRef)(stringAutorelease))); 这段代码的输出结果是什么呢？在ARC下运行结果为 11-2 [NSString stringWithFormat:@”Hello, World!”]和[[NSString alloc] initWithFormat:@”Hello, World!”]有什么区别？ 解释：NSString *string = [[NSString alloc] initWithFormat:@”Hello, World!”] 这个需要手动释放内存 NSString *string1 = [NSString stringWithFormat:@”Hello, World!”]; 是 autorelease的，不用需要手动释放内存 参考：http://blog.sina.com.cn/s/blog_716de00901017tnh.htmlhttps://www.cnblogs.com/zhangdashao/p/4444842.html]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSString</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[autoreleasepool]]></title>
    <url>%2F2018%2F01%2F08%2F20180108-autoreleasepool%2F</url>
    <content type="text"><![CDATA[2018-01-08 立个flag , 今天看完autoreleasepool的相关知识。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>autoreleasepool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存管理方式]]></title>
    <url>%2F2018%2F01%2F07%2F20180107-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[先立个flag，明天搞懂操作系统的内存管理方式，包括块式、页式、段式等。已完成]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用assign修饰object类型会怎样？]]></title>
    <url>%2F2018%2F01%2F05%2F20180105-%E7%94%A8assign%E4%BF%AE%E9%A5%B0object%E7%B1%BB%E5%9E%8B%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[转自：https://www.jianshu.com/p/14e947dab4f9用assign修饰object类型会怎样？在我们的编码过程中已经养成了使用assign修复基本数据类型的良好习惯，我们不会去使用assign修饰对象类型属性，但是如果用assign去修复对象类型会怎样呢，你可能会有以下猜测： 1.编译会报错；2.编译不报错，运行正常；3.编译不报错，运行不正常； 开始实验 首先定义一个简单的object类型，重写dealloc方便查看对象的释放 1234567891011121314151617181920@interface TestObject : NSObject@property (nonatomic, assign) NSInteger age;@end@implementation TestObject- (void)dealloc &#123;NSLog(@&quot;%s&quot;, __FUNCTION__);&#125;@end@interface BasicViewController : BaseViewController@property (nonatomic ,assign) TestObject *property1;@end 测试一 1234- (void)test &#123;self.property1 = [TestObject new];self.property1.age = 1;&#125; 测试二 12345- (void)test &#123;TestObject *obj = [TestObject new];self.property1 = obj;self.property1.age = 1;&#125; 实验结果和分析 测试一 结果：测试一会在self.property1 = [TestObject new];这一行报出警告，单步调试后发现TestObject对象会在创建完以后被释放，所以下面self.property1.age = 1属性赋值将直接引发crash：EXC_BAD_ACCESS，这就是是所谓的野指针。 分析：因为TestObject new对象创建出来没有任何强指针指向它，所以创建完以后立即会被释放了，这时候self.property1指针指向的地方已经不可用，所以就成了野指针。 测试二 结果：编译正常没有警告，运行正常也没有报错，但是在test方法调用之后如果你再去调用属性property1同样会引发EXC_BAD_ACCESS。 分析：因为obj是test方法内的临时变量，ARC模式下编译器会在test方法的末尾调用obj release，所以一旦test方法执行完毕以后，该临时变量就会被释放，此时self.property1将变为野指针。由于这种情况下在编译阶段我们的代码都不会有任何的警告，而运行时该属性变为野指针之后，我们在任何地方调用就会引发野指针崩溃，这是很危险的。在快速编码的时候，很有可能由于我们的复制粘贴属性的定义而把object类型属性用assign修饰，因为曾经就遇到过同事留下的这种坑，从逻辑上找根本找不错错误，仔细检视代码才发现了这个低级错误]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>assign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个Objective-C对象的内存结构发布]]></title>
    <url>%2F2018%2F01%2F05%2F20180105-%E4%B8%80%E4%B8%AAObjective-C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[转自：https://www.cnblogs.com/chrisbin/articles/6486906.html 一个 Objective-C 对象的内存结构是怎样的？ 如果把类的实例看成一个C语言的结构体（struct），它首先包含的是一个 isa 指针，而类的其它成员变量依次排列在结构体中。排列顺序如下图所示： 为了验证该说法，我们在Xcode中新建一个工程，在main.m中运行如下代码： 1234567891011121314151617181920212223242526#import &lt;UIKit/UIKit.h&gt;@interface Father : NSObject &#123;int _father;&#125;@end@implementation Father@end@interface Child : Father &#123;int _child;&#125;@end@implementation Child@endint main(int argc, char * argv[])&#123;Child * child = [[Child alloc] init];@autoreleasepool &#123;// ...&#125;&#125; 我们将断点下在 @autoreleasepool 处，然后在Console中输入p *child,则可以看到Xcode输出如下内容，这与我们上面的说法一致。 12345678910(lldb) p *child(Child) $0 = &#123;(Father) Father = &#123;(NSObject) NSObject = &#123;(Class) isa = Child&#125;(int) _father = 0&#125;(int) _child = 0&#125; 因为对象在内存中的排布可以看成一个结构体，该结构体的大小并不能动态变化。所以无法在运行时动态给对象增加成员变量。 注：需要特别说明一下，通过 objc_setAssociatedObject 和 objc_getAssociatedObject方法可以变相地给对象增加成员变量，但由于实现机制不一样，所以并不是真正改变了对象的内存结构。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解的Objective-C:类别]]></title>
    <url>%2F2018%2F01%2F04%2F20180104-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E7%9A%84Objective-C-%E7%B1%BB%E5%88%AB%2F</url>
    <content type="text"><![CDATA[转自美团点评计数团队https://tech.meituan.com/DiveIntoCategory.html 摘要无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如目录已经遍布于Objective-C代码的各个角落，从Apple官方的框架到各个开源框架，从功能繁复的大型APP到简单的应用，产品类别无处不在。本文对类别做了比较全面的整理，希望对读者有所裨益。 目录初入宝地-category简介 连类比事-category和扩展 挑灯细览-category真面目 追本溯源-category如何加载 旁枝末叶-category和+负载方法 触类旁通-category和方法覆盖 更上一层-category和关联对象 1，初入宝地-category简介category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景 可以把类的实现分开在几个不同的文件里面。这样做可以减少单个文件的体积。开发者共同完成一个类d）可以按需加载想要的类别等。 声明私有方法 不过除了苹果推荐的使用场景，广大开发者脑洞大开，还衍生出了类的其他几个使用场景： 模拟多继承 把框架的私有方法公开 目标C的这个语言特性对于纯动态语言来说可能不算什么，比如JavaScript中，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。 2，连类比事-category和扩展扩展看起来很像一个匿名的范畴，但是扩展和有名字的范畴几乎完全是两个东西。扩展在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。扩展名一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加扩展，所以你无法为系统的类比如NSString添加扩展名（详见2） 但是类别则完全不一样，它是在运行期决议的。就类别和扩展的区别来看，我们可以推导出一个明显的事实，扩展可以添加实例变量，而类别是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。 3，挑灯细览-category真面目我们知道，所有的OC类和对象，在运行时层都是用结构表示的，类别也不例外，在运行时层，类别用结构体category_t（在objc-运行时new.h中可以找到此定义），它包含了1），类的名字（名称）2），类（CLS）3），类中所有给类添加的实例方法的列表（instanceMethods）4），类中所有添加的类方法的列表（classMethods ）5），category实现的所有协议的列表（protocols）6），category中添加的所有属性（instanceProperties） 12345678typedef struct category_t &#123;const char *name;classref_t cls;struct method_list_t *instanceMethods;struct method_list_t *classMethods;struct protocol_list_t *protocols;struct property_list_t *instanceProperties;&#125; category_t; 从类别的定义也可以看出类的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。确定，我们先去写一个类别看一下类别到底为何物： MyClass.h： 123456789101112131415161718192021222324252627282930313233343536#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject- (void)printName;@end@interface MyClass(MyAddition)@property(nonatomic, copy) NSString *name;- (void)printName;@endMyClass.m：#import &quot;MyClass.h&quot;@implementation MyClass- (void)printName&#123;NSLog(@&quot;%@&quot;,@&quot;MyClass&quot;);&#125;@end@implementation MyClass(MyAddition)- (void)printName&#123;NSLog(@&quot;%@&quot;,@&quot;MyAddition&quot;);&#125;@end 我们使用铿锵的命令去看看类别到底会变成什么： 1clang -rewrite-objc MyClass.m 好吧，我们得到了一个3M大小，10W多行的的.cpp文件（这绝对是苹果值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static struct /*_method_list_t*/ &#123;unsigned int entsize; // sizeof(struct _objc_method)unsigned int method_count;struct _objc_method method_list[1];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_objc_method),1,&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_MyClass_MyAddition_printName&#125;&#125;&#125;;static struct /*_prop_list_t*/ &#123;unsigned int entsize; // sizeof(struct _prop_t)unsigned int count_of_properties;struct _prop_t prop_list[1];&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;sizeof(_prop_t),1,&#123;&#123;&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;&#125;&#125;;extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =&#123;&quot;MyClass&quot;,0, // &amp;OBJC_CLASS_$_MyClass,(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,0,0,(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,&#125;;static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) &#123;_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;&#125;#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;(void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,&#125;;static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;&amp;OBJC_CLASS_$_MyClass,&#125;;static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123;&amp;OBJC_CLASS_$_MyClass,&#125;;static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,&#125;; 我们可以看到， 1），首先编译器生成了实例方法列表OBJC $ _CATEGORY_INSTANCE_METHODS MyClass $ _MyAddition和属性列表OBJC $ _PROP_LIST MyClass $ _MyAddition，两者的命名都遵循了公共前缀+类名+类别名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个类别里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的名称属性。还有一个需要注意到的事实就是类的名字用来给各种列表以及后面的类别结构体本身命名，而且有静态来修饰，所以在同一个编译单元里我们的类别名不能重复，否则会出现编译错误。 2），其次，编译器生成了类别本身OBJC $ _CATEGORY MyClass的 $ _MyAddition，并用前面生成的列表来初始化类本身。 3），最后，编译器在DATA段下的 objc_catlist部里保存了一个大小为1的category_t的数组L_OBJCLABEL CATEGORY $（当然，如果有多 类别，会生成对应长度的数组^ ^），用于运行期类的加载。到这里，编译器的工作就接近尾声了，对于类在运行期怎么加载，我们下节揭晓。 4，追本溯源-category如何加载我们知道，Objective-C的运行是依赖OC的运行时的，而OC的运行时和其他系统库一样，是OS X和iOS通过dyld动态加载的。想了解更多dyld地同学可以移步这里 。 对于超频运行时，入口方法如下（在objc-os.mm文件中）： 123456789101112131415161718void _objc_init(void)&#123;static bool initialized = false;if (initialized) return;initialized = true;// fixme defer initialization until an objc-using image is found?environ_init();tls_init();lock_init();exception_init();// Register for unmap first, in case some +load unmaps something_dyld_register_func_for_remove_image(&amp;unmap_image);dyld_register_image_state_change_handler(dyld_image_state_bound,1/*batch*/, &amp;map_images);dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; 类别被附加到类上面是在map_images的时候发生的，在新ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Discover categories.for (EACH_HEADER) &#123;category_t **catlist =_getObjc2CategoryList(hi, &amp;count);for (i = 0; i &lt; count; i++) &#123;category_t *cat = catlist[i];class_t *cls = remapClass(cat-&gt;cls);if (!cls) &#123;// Category&apos;s target class is missing (probably weak-linked).// Disavow any knowledge of this category.catlist[i] = NULL;if (PrintConnecting) &#123;_objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;&quot;missing weak-linked target class&quot;,cat-&gt;name, cat);&#125;continue;&#125;// Process this category.// First, register the category with its target class.// Then, rebuild the class&apos;s method lists (etc) if// the class is realized.BOOL classExists = NO;if (cat-&gt;instanceMethods || cat-&gt;protocols|| cat-&gt;instanceProperties)&#123;addUnattachedCategoryForClass(cat, cls, hi);if (isRealized(cls)) &#123;remethodizeClass(cls);classExists = YES;&#125;if (PrintConnecting) &#123;_objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,getName(cls), cat-&gt;name,classExists ? &quot;on existing class&quot; : &quot;&quot;);&#125;&#125;if (cat-&gt;classMethods || cat-&gt;protocols/* || cat-&gt;classProperties */)&#123;addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);if (isRealized(cls-&gt;isa)) &#123;remethodizeClass(cls-&gt;isa);&#125;if (PrintConnecting) &#123;_objc_inform(&quot;CLASS: found category +%s(%s)&quot;,getName(cls), cat-&gt;name);&#125;&#125;&#125;&#125; 首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和类本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和负载机制。略去PrintConnecting这个用于在日志的东西，这段代码很容易理解： 1），把category的实例方法，协议以及属性添加到类上 2），把category的类方法和协议添加到类的元类上 值得注意的是，在代码中有一小段注释/ || cat-&gt; classProperties /，看来苹果有过给类添加属性的计划啊。ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：在上述的代码片段里，addUnattachedCategoryForClass只是把类和类别做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。 12345678910111213141516171819202122232425262728293031323334353637383940414243static void remethodizeClass(class_t *cls)&#123;category_list *cats;BOOL isMeta;rwlock_assert_writing(&amp;runtimeLock);isMeta = isMetaClass(cls);// Re-methodizing: check for more categoriesif ((cats = unattachedCategoriesForClass(cls))) &#123;chained_property_list *newproperties;const protocol_list_t **newprotos;if (PrintConnecting) &#123;_objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;);&#125;// Update methods, properties, protocolsBOOL vtableAffected = NO;attachCategoryMethods(cls, cats, &amp;vtableAffected);newproperties = buildPropertyList(NULL, cats, isMeta);if (newproperties) &#123;newproperties-&gt;next = cls-&gt;data()-&gt;properties;cls-&gt;data()-&gt;properties = newproperties;&#125;newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols);if (cls-&gt;data()-&gt;protocols &amp;&amp; cls-&gt;data()-&gt;protocols != newprotos) &#123;_free_internal(cls-&gt;data()-&gt;protocols);&#125;cls-&gt;data()-&gt;protocols = newprotos;_free_internal(cats);// Update method caches and vtablesflushCaches(cls);if (vtableAffected) flushVtables(cls);&#125;&#125; 而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods： 12345678910111213141516171819202122232425262728static voidattachCategoryMethods(class_t *cls, category_list *cats,BOOL *inoutVtablesAffected)&#123;if (!cats) return;if (PrintReplacedMethods) printReplacements(cls, cats);BOOL isMeta = isMetaClass(cls);method_list_t **mlists = (method_list_t **)_malloc_internal(cats-&gt;count * sizeof(*mlists));// Count backwards through cats to get newest categories firstint mcount = 0;int i = cats-&gt;count;BOOL fromBundle = NO;while (i--) &#123;method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);if (mlist) &#123;mlists[mcount++] = mlist;fromBundle |= cats-&gt;list[i].fromBundle;&#125;&#125;attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);_free_internal(mlists);&#125; attachCategoryMethods做的工作相对比较简单，它只是把所有类别的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^ _ ^），这个方法有点长，我们只看一小段： 123456789101112131415161718192021222324for (uint32_t m = 0;(scanForCustomRR || scanForCustomAWZ) &amp;&amp; m &lt; mlist-&gt;count;m++)&#123;SEL sel = method_list_nth(mlist, m)-&gt;name;if (scanForCustomRR &amp;&amp; isRRSelector(sel)) &#123;cls-&gt;setHasCustomRR();scanForCustomRR = false;&#125; else if (scanForCustomAWZ &amp;&amp; isAWZSelector(sel)) &#123;cls-&gt;setHasCustomAWZ();scanForCustomAWZ = false;&#125;&#125;// Fill method list arraynewLists[newCount++] = mlist;...// Copy old methods to the method list arrayfor (i = 0; i &lt; oldCount; i++) &#123;newLists[newCount++] = oldLists[i];&#125; 需要注意的有两点： 1），category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA 2），category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^ _ ^，殊不知后面可能还有一样名字的方法。 5，旁枝末叶-category和+负载方法我们知道，在类和类中都可以有+ load方法，那么有两个问题： 1），在类的+ load方法调用的时候，我们可以调用category中声明的方法么？ 2），这么些个+负载方法，调用顺序是咋样的呢？ 鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的： 我们的代码里有MyClass和MyClass的两个类（Category1和Category2），MyClass和两个category都添加了+ load方法，并且Category1和Category2都写了MyClass的printName方法。在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行负载方法以及加载类的时候打印日志信息，更多的环境变量选项可参见objc-private.h）： 运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下： objc [1187]：REPLACED： - [MyClass printName]按类别Category1 objc [1187]：REPLACED： - [MyClass printName]按类别Category2 。。。 objc：LOAD：被调度用于+负载 objc的类“MyClass”：负载：被调度用于+负载objc的类别“MyClass（Category1）”：负载：被调度用于+的类别“MyClass（Category2） load objc [1187]：LOAD：+ [MyClass load] 。。。 objc：LOAD：+ [MyClass（Category1）load] 。。。 objc：LOAD：+ [MyClass（Category2）load] 所以，对于上面两个问题，答案是很明显的： 1），可以调用，因为附加类到类的工作会先于+加载方法的执行 2），加载的执行顺序是先类，后类，而类别的+负载执行顺序是根据编译顺序决定的。 目前的编译顺序是这样的： 我们调整一个组别和类别2的编译顺序，run.ok，我们可以看到控制台的输出顺序变了： objc [1187]：REPLACED： - 按类别Category2的[MyClass printName] objc [1187]：REPLACED： - 按类别Category1的[MyClass printName] 。。。 objc：LOAD：被计划用于+加载 objc的类“MyClass”：LOAD：被计划用于加载objc的类别“MyClass（Category2）”：LOAD：被计划用于加载的 类别“MyClass（Category1） load objc [1187]：LOAD：+ [MyClass load] 。。。 objc：LOAD：+ [MyClass（Category2）load] 。。。 objc：LOAD：+ [MyClass（Category1）load] 虽然对于+负载的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的类里的对应方法。这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。 6，触类旁通-category和方法覆盖鉴于上面几节我们已经把原理都讲了，这一节只有一个问题：？怎么调用到原来类中被分类掉覆盖的方法 对于这个问题，我们已经知道的类别其实并不是完全替换掉原来类的同名方法，只是类别在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法： 12345678910111213141516171819202122232425Class currentClass = [MyClass class];MyClass *my = [[MyClass alloc] init];if (currentClass) &#123;unsigned int methodCount;Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);IMP lastImp = NULL;SEL lastSel = NULL;for (NSInteger i = 0; i &lt; methodCount; i++) &#123;Method method = methodList[i];NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))encoding:NSUTF8StringEncoding];if ([@&quot;printName&quot; isEqualToString:methodName]) &#123;lastImp = method_getImplementation(method);lastSel = method_getName(method);&#125;&#125;typedef void (*fn)(id,SEL);if (lastImp != NULL) &#123;fn f = (fn)lastImp;f(my,lastSel);&#125;free(methodList);&#125; 7，更上一层-category和关联对象如上所见，我们知道在类别里面是无法为类添加实例变量的。但是我们很多时候需要在类别中添加和对象关联的值，这个时候可以求助关联对象来实现。 MyClass的+ Category1.h： 1234567#import &quot;MyClass.h&quot;@interface MyClass (Category1)@property(nonatomic,copy) NSString *name;@end MyClass的+ Category1.m： 12345678910111213141516171819202122232425#import &quot;MyClass+Category1.h&quot;#import &lt;objc/runtime.h&gt;@implementation MyClass (Category1)+ (void)load&#123;NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);&#125;- (void)setName:(NSString *)name&#123;objc_setAssociatedObject(self,&quot;name&quot;,name,OBJC_ASSOCIATION_COPY);&#125;- (NSString*)name&#123;NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;);return nameObject;&#125;@end 但是关联对象又是存在什么地方呢？如何存储？对象销毁时候如何处理关联对象呢？我们去翻一下运行时的源码，在objc-references.mm文件中有个方法_object_set_associative_reference： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;// retain the new value (if any) outside the lock.ObjcAssociation old_association(0, nil);id new_value = value ? acquireValue(value, policy) : nil;&#123;AssociationsManager manager;AssociationsHashMap &amp;associations(manager.associations());disguised_ptr_t disguised_object = DISGUISE(object);if (new_value) &#123;// break any existing association.AssociationsHashMap::iterator i = associations.find(disguised_object);if (i != associations.end()) &#123;// secondary table existsObjectAssociationMap *refs = i-&gt;second;ObjectAssociationMap::iterator j = refs-&gt;find(key);if (j != refs-&gt;end()) &#123;old_association = j-&gt;second;j-&gt;second = ObjcAssociation(policy, new_value);&#125; else &#123;(*refs)[key] = ObjcAssociation(policy, new_value);&#125;&#125; else &#123;// create the new association (first time).ObjectAssociationMap *refs = new ObjectAssociationMap;associations[disguised_object] = refs;(*refs)[key] = ObjcAssociation(policy, new_value);_class_setInstancesHaveAssociatedObjects(_object_getClass(object));&#125;&#125; else &#123;// setting the association to nil breaks the association.AssociationsHashMap::iterator i = associations.find(disguised_object);if (i != associations.end()) &#123;ObjectAssociationMap *refs = i-&gt;second;ObjectAssociationMap::iterator j = refs-&gt;find(key);if (j != refs-&gt;end()) &#123;old_association = j-&gt;second;refs-&gt;erase(j);&#125;&#125;&#125;&#125;// release the old value (outside of the lock).if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下： 12345678910111213class AssociationsManager &#123;static OSSpinLock _lock;static AssociationsHashMap *_map; // associative references: object pointer -&gt; PtrPtrHashMap.public:AssociationsManager() &#123; OSSpinLockLock(&amp;_lock); &#125;~AssociationsManager() &#123; OSSpinLockUnlock(&amp;_lock); &#125;AssociationsHashMap &amp;associations() &#123;if (_map == NULL)_map = new AssociationsHashMap();return *_map;&#125;&#125;; AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局映射里面。而绘制的的关键是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个地图的值又是另外一个AssociationsHashMap，里面保存了关联对象的KV对。而在对象的销毁逻辑里面，见objc-runtime-new.mm： 12345678910111213141516171819void *objc_destructInstance(id obj)&#123;if (obj) &#123;Class isa_gen = _object_getClass(obj);class_t *isa = newcls(isa_gen);// Read all of the flags at once for performance.bool cxx = hasCxxStructors(isa);bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);// This order is important.if (cxx) object_cxxDestruct(obj);if (assoc) _object_remove_assocations(obj);if (!UseGC) objc_clear_deallocating(obj);&#125;return obj;&#125; 嗯，运行时的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。 后记正如侯捷先生所讲 - “源码面前，了无秘密”，苹果的Cocoa Touch框架虽然并不开源，但是Objective-C的运行时和Core Foundation却是完全开放源码的（在http：//www.opensource .apple.com /压缩包/可以下载到全部的开源代码）。本系列运行时源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>category</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[category重写了方法的调用]]></title>
    <url>%2F2018%2F01%2F04%2F20180104-category%E9%87%8D%E5%86%99%E4%BA%86%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MyClass123456789101112131415#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject@property(nonatomic,copy)NSString *name;- (void)printName;@end#import &quot;MyClass.h&quot;@implementation MyClass- (void)printName&#123;NSLog(@&quot;MyClass-printName&quot;);&#125;@end MyClass+MyAddition 1234567891011121314#import &quot;MyClass.h&quot;@interface MyClass (MyAddition)@property(nonatomic,copy)NSString *name;- (void)printName;@end#import &quot;MyClass+MyAddition.h&quot;@implementation MyClass (MyAddition)-(void)printName&#123;NSLog(@&quot;MyClass-MyAddition-printName&quot;);&#125;@end MyClass+MyAddition1 1234567891011121314#import &quot;MyClass.h&quot;@interface MyClass (MyAddition1)@property(nonatomic,copy)NSString *name;- (void)printName;@end#import &quot;MyClass+MyAddition1.h&quot;@implementation MyClass (MyAddition1)-(void)printName&#123;NSLog(@&quot;MyClass-MyAddition1-printName&quot;);&#125;@end main.m 123456789101112#import &lt;Foundation/Foundation.h&gt;#import &quot;MyClass.h&quot;int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;// insert code here...//NSLog(@&quot;Hello, World!&quot;);MyClass *myClass = [[MyClass alloc] init];[myClass printName];&#125;return 0;&#125; 我们都知道如果一个类的分类重写了这个类的方法后，那么这个类的这个方法将失效，起作用的将会是分类的那个重写方法，在分类重写的时候Xcode也会给出相应警告：Category is implementing a method which will also be implemented by its primary class那如果两个分类都重写了这个类的方法呢？运行结果是什么呢？ 首先，我们先了解一下原方法失效，分类方法生效的原理。想弄清这点先来看一下类的初始化，首先oc是动态语言，建立在runtime 的基础上，同样类的初始化也是动态的，根类NSObject 的+load 和+initilize两个方法，用于类的初始化，我们这里要着重看的是+load方法: +load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法执行之后执行，而分类的 +load 方法会在它的主类的 +load 方法执行之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。接下来我们来验证一下：修改mian.m的代码 1234567891011121314151617181920#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import &quot;MyClass.h&quot;int main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;// insert code here...//NSLog(@&quot;Hello, World!&quot;);id LenderClass = objc_getClass(&quot;MyClass&quot;);unsigned int outCount, i;//获取实例方法列表Method *methodList = class_copyMethodList(LenderClass, &amp;outCount);for (i=0; i&lt;outCount; i++) &#123;Method method = methodList[i];NSLog(@&quot;instanceMethod：%@&quot;, NSStringFromSelector(method_getName(method)));&#125;MyClass *myClass = [[MyClass alloc] init];[myClass printName];&#125;return 0;&#125; 输出结果为： 12345678instanceMethod：printNameinstanceMethod：printNameinstanceMethod：printNameinstanceMethod：.cxx_destructinstanceMethod：nameinstanceMethod：setName:MyClass-MyAddition-printNameProgram ended with exit code: 0 可以方法列表中有3个printName，实际调用时，调用的是后添加的方法，即后添加的方法在方法列表methodLists的这个数组的顶部。所以objc_msgSend遍历方法列表查找SEL 对应的IMP时，会先找到分类重写的那个，调用执行。然后添加到缓存列表中，这样主类方法实现永远也不会调到。 那分类load 的顺序是怎么确定的呢？在Xcode中找到buildPhases-&gt;Compile Sources。 如图： 总结一句话：类的加载顺序，决定方法的添加顺序，调用的时候，后添加的方法会先被找到，所以调用的始终是后加载的类的方法实现。 参考：http://blog.csdn.net/JaimeCool/article/details/76071630?locationNum=2https://tech.meituan.com/DiveIntoCategory.html]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>category</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[LeetCode]42.Trapping Rain Water]]></title>
    <url>%2F2018%2F01%2F02%2F20180102-LeetCode-42-Trapping-Rain-Water%2F</url>
    <content type="text"><![CDATA[https://leetcode.com/problems/trapping-rain-water/description/Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. For example,Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString和NSMutableString分别使用copy和mutablecopy]]></title>
    <url>%2F2017%2F12%2F29%2F20171229-NSString%E5%92%8CNSMutableString%E5%88%86%E5%88%AB%E4%BD%BF%E7%94%A8copy%E5%92%8Cmutablecopy%2F</url>
    <content type="text"><![CDATA[可变集合类使用copy表示深拷贝，使用mutablecopy表示深拷贝。不可变集合类使用copy的时候是浅拷贝，使用metableCopy表示深拷贝。测试 1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;Foundation/Foundation.h&gt;void copyDemo1()&#123; NSLog(@&quot;1.NSMutableString&quot;); NSMutableString *arrayM = [NSMutableString stringWithFormat:@&quot;abcabcabca&quot;]; NSLog(@&quot;%p %@&quot;, arrayM, arrayM.class); NSMutableString *a1 = [arrayM mutableCopy]; NSLog(@&quot;%p %@&quot;, a1, a1.class); [a1 appendString:@&quot;de&quot;]; NSString *a2 = [arrayM mutableCopy]; NSLog(@&quot;%p %@&quot;, a2, a2.class); NSMutableString *a3 = [arrayM copy]; NSLog(@&quot;%p %@&quot;, a3, a3.class); NSString *a4 = [arrayM copy]; NSLog(@&quot;%p %@&quot;, a4, a4.class);&#125;void copyDemo2()&#123; NSLog(@&quot;2.NSString&quot;); NSString *arrayI = [NSString stringWithFormat:@&quot;abcaaaaaaaaa&quot;]; NSLog(@&quot;%p %@&quot;, arrayI, arrayI.class); NSMutableString *a1 = [arrayI mutableCopy]; NSLog(@&quot;%p %@&quot;, a1, a1.class); NSString *a2 = [arrayI mutableCopy]; NSLog(@&quot;%p %@&quot;, a2, a2.class); NSMutableString *a3 = [arrayI copy]; NSLog(@&quot;%p %@&quot;, a3, a3.class); NSString *a4 = [arrayI copy]; NSLog(@&quot;%p %@&quot;, a4, a4.class);&#125;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... copyDemo1(); copyDemo2(); &#125; return 0;&#125; 运行结果： 1234567891011121.NSMutableString0x10063a870 __NSCFString0x100739be0 __NSCFString0x100636d10 __NSCFString0x10063c3d0 __NSCFString0x10063c420 __NSCFString2.NSString0x10063bb80 __NSCFString0x100739be0 __NSCFString0x100739720 __NSCFString0x10063bb80 __NSCFString0x10063bb80 __NSCFString 关于容器实现copy 或 metableCopy ，容器内元素默认都是指针拷贝,不是内容复制。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSString</tag>
        <tag>NSMutableString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString属性copy和strong]]></title>
    <url>%2F2017%2F12%2F29%2F20171229-NSString%E5%B1%9E%E6%80%A7copy%E5%92%8Cstrong%2F</url>
    <content type="text"><![CDATA[我们在编码中用到NSString类型变量时，都使用的是copy。但是也一直没有弄懂为什么用copy。测试 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;@interface TestStringClass :NSObject@property (nonatomic, strong) NSString* strongString;@property (nonatomic, copy) NSString* copyedString;@end@implementation TestStringClass- (void)test &#123; NSString *string = [NSString stringWithFormat:@&quot;1234&quot;]; self.strongString = string; self.copyedString = string; NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string); NSLog(@&quot;strong string: %p, %p&quot;, _strongString, &amp;_strongString); NSLog(@&quot;copy string: %p, %p&quot;, _copyedString, &amp;_copyedString);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; TestStringClass *testStringClass = [[TestStringClass alloc] init]; [testStringClass test]; &#125;return 0;&#125; 运行结果为： 123origin string: 0x63626135, 0x7ffeefbff5b8strong string: 0x63626135, 0x100615ab8copy string: 0x63626135, 0x100615ac0 根据运行结果可以看出，不管是strong还是copy属性的对象，其指向的地址都是同一个地址：0x63626135，即为string指向的地址。我们把string由不可变改为可变对象，看看会是什么结果。 123456789- (void)test &#123; //NSString *string = [NSString stringWithFormat:@&quot;1234&quot;]; NSMutableString *string = [NSMutableString stringWithFormat:@&quot;1234&quot;]; self.strongString = string; self.copyedString = string; NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string); NSLog(@&quot;strong string: %p, %p&quot;, _strongString, &amp;_strongString); NSLog(@&quot;copy string: %p, %p&quot;, _copyedString, &amp;_copyedString);&#125; 运行结果为： 123origin string: 0x10053c8d0, 0x7ffeefbff5b8strong string: 0x10053c8d0, 0x10053c818copy string: 0x3433323145, 0x10053c820 可以看出，此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让_copyedString对象指向这个字符串。 而上面的例子可以看出：1.当源字符串是NSString时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。 2.当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSString</tag>
        <tag>property</tag>
        <tag>copy</tag>
        <tag>strong</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime如何实现weak属性]]></title>
    <url>%2F2017%2F12%2F28%2F20171228-runtime%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0weak%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[OC 中的 weak 属性是怎么实现的，为什么在对象释放后会自动变成 nil ？经百度，有个博客（博客地址）给出了一个答案。 runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。 推荐一篇博客，写的很详细http://blog.csdn.net/iJason92/article/details/72808387]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MRC环境下for循环给Block对象类型数组赋值]]></title>
    <url>%2F2017%2F12%2F28%2F20171228-MRC%E7%8E%AF%E5%A2%83%E4%B8%8Bfor%E5%BE%AA%E7%8E%AF%E7%BB%99Block%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[首先，先让大家看一段代码，代码来源（http://blog.csdn.net/weidfyr/article/details/48138167#t5） 1234567891011void function()&#123; int i; int (^blocks[10])(); //定义一个块对象类型的数组 for (i = 0; i &lt; 10; i++) &#123; //for循环给数组赋值 blocks[i] = ^&#123; return i; &#125;; &#125; for (i = 0; i &lt; 10; i++) &#123; //打印数组中的内容，就是每个数组存放的代码块的返回值 NSLog(@&quot;%d&quot;, blocks[i]()); &#125;&#125; 大家可以想一下代码在ARC和MRC环境下的运行结果分别是什么？]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Block</tag>
        <tag>MRC</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画之CAKeyframeAnimation]]></title>
    <url>%2F2017%2F12%2F27%2F20171227-iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCAKeyframeAnimation%2F</url>
    <content type="text"><![CDATA[1.CAKeyframeAnimation介绍CABasicAnimation和CAKeyFrameAnimation都是CAPropertyAnimation的子类，CABasicAnimation算是CAKeyFrameAnimation的 特殊情况。CAKeyFrameAnimation支持关键帧的属性动画，可以通过values属性指定多个关键帧，通过关键帧可以指定动画的各阶段的关键值。 相关属性和说明values 关键帧数组上述的NSArray对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧 path 路径轨迹path：作 用与values属性一样，同样是用于指定整个动画所经过的路径的,可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。注意：values与path是互斥的，当values与path同时指定时，path将会覆盖values keyTimes 关键帧所对应的时间点keyTimes：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的 timeFunctions 时间函数timeFunctions：这个属性用以指定时间函数，类似于运动的加速度，有以下几种类型。 123451 kCAMediaTimingFunctionLinear//线性2 kCAMediaTimingFunctionEaseIn//淡入3 kCAMediaTimingFunctionEaseOut//淡出4 kCAMediaTimingFunctionEaseInEaseOut//淡入淡出5 kCAMediaTimingFunctionDefault//默认 calculationMode属性该属性决定了物体在每个子路径下是跳着走还是匀速走，跟timeFunctions属性有点类似 123451 const kCAAnimationLinear//线性，默认2 const kCAAnimationDiscrete//离散，无中间过程，但keyTimes设置的时间依旧生效，物体跳跃地出现在各个关键帧上3 const kCAAnimationPaced//平均，keyTimes跟timeFunctions失效4 const kCAAnimationCubic//平均，同上5 const kCAAnimationCubicPaced//平均，同上 2.CAKeyframeAnimation 实例2.1.values1234567891011CAKeyframeAnimation *anima = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-50)];NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/3, SCREEN_HEIGHT/2-50)];NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/3, SCREEN_HEIGHT/2+50)];NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH*2/3, SCREEN_HEIGHT/2+50)];NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH*2/3, SCREEN_HEIGHT/2-50)];NSValue *value5 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-50)];anima.values = [NSArray arrayWithObjects:value0,value1,value2,value3,value4,value5, nil];anima.duration = 2.0f;anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];[_demoView.layer addAnimation:anima forKey:@&quot;keyFrameAnimation&quot;]; 2.2.path 12345CAKeyframeAnimation *anima = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(SCREEN_WIDTH/2-100, SCREEN_HEIGHT/2-100, 200, 200)];anima.path = path.CGPath;anima.duration = 2.0f;[_demoView.layer addAnimation:anima forKey:@&quot;pathAnimation&quot;];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>动画</tag>
        <tag>iOS</tag>
        <tag>CAKeyframeAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画之CABasicAnimation]]></title>
    <url>%2F2017%2F12%2F27%2F20171227-iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCABasicAnimation%2F</url>
    <content type="text"><![CDATA[1.CABaseAnimation介绍CABaseAnimation介绍 是 CAPropertyAnimation的子类，简单控制CALayer层的属性慢慢改变，从而实现动画效果。使用方法animationWithKeyPath:对 CABasicAnimation进行实例化，并指定Layer的属性作为关键路径进行注册。例如： 1CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;]; 相关属性和声明属性 | 说明—|—duration | 动画时长repeatCount | 重复次数。不停重复设置为 HUGE_VALFbeginTime | 指定动画开始的时间。从开始延迟几秒的话，设置为[CACurren|tMediaTime() + 秒数] 的方式timingFunction | 动画的速度变化autoreverses | 动画结束时是否执行逆动画fromValue | 起始值toValue | 结束值byValue | 结束值（相对值） 一些常用的animationWithKeyPath值 值 说明 使用形式 transform.scale 比例转化 @(0.8) transform.scale.x 宽的比例 @(0.8) transform.scale.y 高的比例 @(0.8) transform.rotation.x 围绕x轴旋转 @(M_PI) transform.rotation.y 围绕y轴旋转 @(M_PI) transform.rotation.z 围绕z轴旋转 @(M_PI) cornerRadius 圆角的设置 @(50) backgroundColor 背景颜色的变化 (id)[UIColor purpleColor].CGColor bounds 大小，中心不变 [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)]; position 位置(中心点的改变) [NSValue valueWithCGPoint:CGPointMake(300, 300)]; contents 内容，比如UIImageView的图片 imageAnima.toValue = (id)[UIImage imageNamed:@”to”].CGImage; opacity 透明度 @(0.7) contentsRect.size.width 横向拉伸缩放 @(0.4)最好是0~1之间的 2.CABasicAnimation的使用示例 2.1.移动动画 123456CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];anima.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-75)];anima.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-75)];anima.duration = 1.0f;anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];[_demoView.layer addAnimation:anima forKey:@&quot;positionAnimation&quot;]; 2.2.透明度动画 12345CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];anima.fromValue = [NSNumber numberWithFloat:1.0f];anima.toValue = [NSNumber numberWithFloat:0.2f];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;opacityAniamtion&quot;]; 2.3.缩放动画 123456789CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;];anima.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 100)];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;];// CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];//同上// anima.toValue = [NSNumber numberWithFloat:2.0f];// anima.duration = 1.0f;// [_demoView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;]; 2.4.旋转动画 1234567891011CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];//绕着z轴为矢量，进行旋转(@&quot;transform.rotation.z&quot;==@@&quot;transform.rotation&quot;)anima.toValue = [NSNumber numberWithFloat:M_PI];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;rotateAnimation&quot;];// //valueWithCATransform3D作用与layer// CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];// anima.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI, 0, 0, 1)];//绕着矢量（x,y,z）旋转// anima.duration = 1.0f;// //anima.repeatCount = MAXFLOAT;// [_demoView.layer addAnimation:anima forKey:@&quot;rotateAnimation&quot;]; 2.5.背景色动画 1234CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];anima.toValue =(id) [UIColor greenColor].CGColor;anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;backgroundAnimation&quot;];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CABasicAnimation</tag>
        <tag>动画</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString与TaggedPoint技术]]></title>
    <url>%2F2017%2F12%2F26%2F20171226-NSString%E4%B8%8ETaggedPoint%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1.问题在学习iOS中的NSString时，看到了掘金上的一篇文章 一个毫无道理的iOS问题1234567891011121314151617181920212223242526272829303132@interface ViewController ()@property (nonatomic, strong) NSString *string1;@property (nonatomic, assign) NSString *string2;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;1.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1&quot;]; self.string2 = self.string1; self.string1 = nil; NSLog(@&quot;string2 = %@&quot;,self.string2); NSLog(@&quot;2.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1234&quot;]; self.string2 = self.string1; self.string1 = nil; NSLog(@&quot;string2 = %@&quot;,self.string2);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 提问：第16行和第22行的执行结果分别是什么？测试后发现这段代码的问题是这样的:1.第16行执行后并不会崩溃，第22行执行后会崩溃2.只有字符串的内容长度超过10字节才会奔溃崩溃 2.解释我们修改代码查看两种情况下string1和string2的指针地址已经指针所存储的数据。 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;1.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;SSS&quot;]; self.string2 = self.string1; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); self.string1 = nil; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); NSLog(@&quot;string2 = %@&quot;,self.string2); NSLog(@&quot;\n\n&quot;); NSLog(@&quot;2.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1234&quot;]; self.string2 = self.string1; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); self.string1 = nil; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); NSLog(@&quot;string2 = %@&quot;,self.string2);&#125; 运行时第22行出现异常，我们先看一下第一种情况的打印信息。 1234561.-------string1 = 0xa000000005353533 0x15dd39540 SSS NSTaggedPointerStringstring2 = 0xa000000005353533 0x15dd39548 SSS NSTaggedPointerStringstring1 = 0x0 0x15dd39540 (null) (null)string2 = 0xa000000005353533 0x15dd39548 SSS NSTaggedPointerStringstring2 = SSS 可以看出0x15dd39540和0x15dd39548是两个堆指针，指针存储的数据是0xa000000005353533，可以看出0xa000000005353533不是一个有效地址，这是因为iOS使用了TaggedPoint技术，此时“SSS”这个字符串并不是存储在堆上，而是存储在self.string这个指针里面，self.string2=self.string1，完全就是一个赋值操作，不存在指向堆内存的问题，所以不会出现异常。关于TaggedPoint的详细介绍，给大家推荐一篇博客：深入理解Tagged Pointer 接下来我们看一下第二种情况的打印信息。 12342.-------string1 = 0x15de0f460 0x15dd39540 string1234 __NSCFStringstring2 = 0x15de0f460 0x15dd39548 string1234 __NSCFStringstring1 = 0x0 0x15dd39540 (null) (null) 从运行结果可以看出，0x15dd39540和0x15dd39548是两个堆指针，里面存的数据都是0x15de0f460，也是一个有效的堆地址，在self.string1=nil之后，0x15dd39540指向的内存区0x15de0f460已经被释放，再用self.string2来访问，0x15dd39548所执向的0x15de0f460已经不存在了，是一个野指针了，所以会野指针crash。 3.参考博客http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSString</tag>
        <tag>TaggedPoint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block引用计数问题]]></title>
    <url>%2F2017%2F12%2F26%2F20171226-Block%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在学习block，在网上看到一个关于block和引用计数的问题:Block 捕获对象类型的变量时的问题123456789typedef void(^Block)();Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数%d&quot;, _objc_rootRetainCount(person));Block block = ^&#123; perons.name = @&quot;Nature&quot;; NSLog(@&quot;Block中person的引用计数%d&quot;, _objc_rootRetainCount(person));&#125;;block();NSLog(@&quot;Block后person的引用计数%d&quot;, _objc_rootRetainCount(person)); 在ARC下运行结果为： 123Block前person的引用计数为1Block中person的引用计数为3Block后person的引用计数为3 为什么block截获person变量后，引用计数会+2？接下来修改了代码，输出person的地址信息 12345678typedef void(^Block)(void);Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));Block block =^&#123; NSLog(@&quot;Block中person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));&#125;;block();NSLog(@&quot;Block后person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person)); 我在MRC 下运行代码，结果为：123Block前person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff628 -0x100547c20Block中person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff618 -0x100547c20Block后person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff628 -0x100547c20 其中 Person: 0x100547c20 为 person 对象信息0x7ffeefbff628 0x7ffeefbff618 为栈上指针，存放的数据是地址0x100547c200x100547c20 为堆上存放person的地址。 从MRC运行结果可以看出 MRC 下，block 内引用person 只复制了一个指针。 我多次运行 发现两个栈指针的差值是固定的，一直都是0x10（不太了解为什么差值一直一样，中间的地址存放的是什么数据）。接下来我在ARC下尝试着将person 的地址减去一个 0x10 , 将新地址的内容输出来。 12345678typedef void(^Block)(void);Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));Block block =^&#123; NSLog(@&quot;Block中person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));&#125;;block();NSLog(@&quot;Block后person的引用计数-%tu -%@ -%p -%p %p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person),(&amp;person-2),*(&amp;person-2)); 运行结果为：123Block前person的引用计数-1 -&lt;Person: 0x1004002b0&gt; -0x7ffeefbff620 -0x1004002b0Block中person的引用计数-3 -&lt;Person: 0x1004002b0&gt; -0x1007114c0 -0x1004002b0Block后person的引用计数-3 -&lt;Person: 0x1004002b0&gt; -0x7ffeefbff620 -0x1004002b0 0x7ffeefbff610 -0x1004002b0 我们发现在ARC下 栈指针 0x7ffeefbff610 和 0x7ffeefbff620 中的存放的数据都是person的地址 0x1004002b0。而在 堆地址0x1007114c0 也引用一份person。所以person的引用计数为3。 所以在ARC模式下，如果block 引用局部变量，先将变量地址复制到栈上，在从栈上复制到堆上。（不知道对不对啊）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
</search>
