<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[20171229-NSString属性copy和strong]]></title>
    <url>%2F2017%2F12%2F29%2F20171229-NSString%E5%B1%9E%E6%80%A7copy%E5%92%8Cstrong%2F</url>
    <content type="text"><![CDATA[我们在编码中用到NSString类型变量时，都使用的是copy。但是也一直没有弄懂为什么用copy。测试 1234567891011121314151617181920212223#import &lt;Foundation/Foundation.h&gt;@interface TestStringClass :NSObject@property (nonatomic, strong) NSString* strongString;@property (nonatomic, copy) NSString* copyedString;@end@implementation TestStringClass- (void)test &#123;NSString *string = [NSString stringWithFormat:@&quot;1234&quot;];self.strongString = string;self.copyedString = string;NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string);NSLog(@&quot;strong string: %p, %p&quot;, _strongString, &amp;_strongString);NSLog(@&quot;copy string: %p, %p&quot;, _copyedString, &amp;_copyedString);&#125;@endint main(int argc, const char * argv[]) &#123;@autoreleasepool &#123;TestStringClass *testStringClass = [[TestStringClass alloc] init];[testStringClass test];&#125;return 0;&#125; 运行结果为： 123origin string: 0x63626135, 0x7ffeefbff5b8strong string: 0x63626135, 0x100615ab8copy string: 0x63626135, 0x100615ac0 根据运行结果可以看出，不管是strong还是copy属性的对象，其指向的地址都是同一个地址：0x63626135，即为string指向的地址。我们把string由不可变改为可变对象，看看会是什么结果。 123456789- (void)test &#123;//NSString *string = [NSString stringWithFormat:@&quot;1234&quot;];NSMutableString *string = [NSMutableString stringWithFormat:@&quot;1234&quot;];self.strongString = string;self.copyedString = string;NSLog(@&quot;origin string: %p, %p&quot;, string, &amp;string);NSLog(@&quot;strong string: %p, %p&quot;, _strongString, &amp;_strongString);NSLog(@&quot;copy string: %p, %p&quot;, _copyedString, &amp;_copyedString);&#125; 运行结果为： 123origin string: 0x10053c8d0, 0x7ffeefbff5b8strong string: 0x10053c8d0, 0x10053c818copy string: 0x3433323145, 0x10053c820 可以看出，此时copy属性字符串已不再指向string字符串对象，而是深拷贝了string字符串，并让_copyedString对象指向这个字符串。 而上面的例子可以看出：1.当源字符串是NSString时，由于字符串是不可变的，所以，不管是strong还是copy属性的对象，都是指向源对象，copy操作只是做了次浅拷贝。 2.当源字符串是NSMutableString时，strong属性只是增加了源字符串的引用计数，而copy属性则是对源字符串做了次深拷贝，产生一个新的对象，且copy属性对象指向这个新的对象。另外需要注意的是，这个copy属性对象的类型始终是NSString，而不是NSMutableString，因此其是不可变的。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSString</tag>
        <tag>property</tag>
        <tag>copy</tag>
        <tag>strong</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[runtime如何实现weak属性]]></title>
    <url>%2F2017%2F12%2F28%2F20171228-runtime%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0weak%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[OC 中的 weak 属性是怎么实现的，为什么在对象释放后会自动变成 nil ？经百度，有个博客（博客地址）给出了一个答案。runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为 0 的时候会 dealloc，假如 weak 指向的对象内存地址是 a ，那么就会以 a 为键， 在这个 weak 表中搜索，找到所有以 a 为键的 weak 对象，从而设置为 nil 。 推荐一篇博客，写的很详细http://blog.csdn.net/iJason92/article/details/72808387]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MRC环境下for循环给Block对象类型数组赋值]]></title>
    <url>%2F2017%2F12%2F28%2F20171228-MRC%E7%8E%AF%E5%A2%83%E4%B8%8Bfor%E5%BE%AA%E7%8E%AF%E7%BB%99Block%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[首先，先让大家看一段代码，代码来源（http://blog.csdn.net/weidfyr/article/details/48138167#t5）1234567891011void function()&#123; int i; int (^blocks[10])(); //定义一个块对象类型的数组 for (i = 0; i &lt; 10; i++) &#123; //for循环给数组赋值 blocks[i] = ^&#123; return i; &#125;; &#125; for (i = 0; i &lt; 10; i++) &#123; //打印数组中的内容，就是每个数组存放的代码块的返回值 NSLog(@&quot;%d&quot;, blocks[i]()); &#125;&#125; 大家可以想一下代码在ARC和MRC环境下的运行结果分别是什么？]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>Block</tag>
        <tag>MRC</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画之CAKeyframeAnimation]]></title>
    <url>%2F2017%2F12%2F27%2F20171227-iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCAKeyframeAnimation%2F</url>
    <content type="text"><![CDATA[1.CAKeyframeAnimation介绍CABasicAnimation和CAKeyFrameAnimation都是CAPropertyAnimation的子类，CABasicAnimation算是CAKeyFrameAnimation的 特殊情况。CAKeyFrameAnimation支持关键帧的属性动画，可以通过values属性指定多个关键帧，通过关键帧可以指定动画的各阶段的关键值。相关属性和说明values 关键帧数组上述的NSArray对象。里面的元素称为“关键帧”(keyframe)。动画对象会在指定的时间（duration）内，依次显示values数组中的每一个关键帧 path 路径轨迹path：作 用与values属性一样，同样是用于指定整个动画所经过的路径的,可以设置一个CGPathRef、CGMutablePathRef，让图层按照路径轨迹移动。path只对CALayer的anchorPoint和position起作用。注意：values与path是互斥的，当values与path同时指定时，path将会覆盖values keyTimes 关键帧所对应的时间点keyTimes：可以为对应的关键帧指定对应的时间点，其取值范围为0到1.0keyTimes中的每一个时间值都对应values中的每一帧。如果没有设置keyTimes，各个关键帧的时间是平分的 timeFunctions 时间函数timeFunctions：这个属性用以指定时间函数，类似于运动的加速度，有以下几种类型。 123451 kCAMediaTimingFunctionLinear//线性2 kCAMediaTimingFunctionEaseIn//淡入3 kCAMediaTimingFunctionEaseOut//淡出4 kCAMediaTimingFunctionEaseInEaseOut//淡入淡出5 kCAMediaTimingFunctionDefault//默认 calculationMode属性该属性决定了物体在每个子路径下是跳着走还是匀速走，跟timeFunctions属性有点类似 123451 const kCAAnimationLinear//线性，默认2 const kCAAnimationDiscrete//离散，无中间过程，但keyTimes设置的时间依旧生效，物体跳跃地出现在各个关键帧上3 const kCAAnimationPaced//平均，keyTimes跟timeFunctions失效4 const kCAAnimationCubic//平均，同上5 const kCAAnimationCubicPaced//平均，同上 2.CAKeyframeAnimation 实例2.1.values1234567891011CAKeyframeAnimation *anima = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];NSValue *value0 = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-50)];NSValue *value1 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/3, SCREEN_HEIGHT/2-50)];NSValue *value2 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH/3, SCREEN_HEIGHT/2+50)];NSValue *value3 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH*2/3, SCREEN_HEIGHT/2+50)];NSValue *value4 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH*2/3, SCREEN_HEIGHT/2-50)];NSValue *value5 = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-50)];anima.values = [NSArray arrayWithObjects:value0,value1,value2,value3,value4,value5, nil];anima.duration = 2.0f;anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut];[_demoView.layer addAnimation:anima forKey:@&quot;keyFrameAnimation&quot;]; 2.2.path 12345CAKeyframeAnimation *anima = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(SCREEN_WIDTH/2-100, SCREEN_HEIGHT/2-100, 200, 200)];anima.path = path.CGPath;anima.duration = 2.0f;[_demoView.layer addAnimation:anima forKey:@&quot;pathAnimation&quot;];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>动画</tag>
        <tag>CAKeyframeAnimation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画之CABasicAnimation]]></title>
    <url>%2F2017%2F12%2F27%2F20171227-iOS%E5%8A%A8%E7%94%BB%E4%B9%8BCABasicAnimation%2F</url>
    <content type="text"><![CDATA[1.CABaseAnimation介绍CABaseAnimation介绍 是 CAPropertyAnimation的子类，简单控制CALayer层的属性慢慢改变，从而实现动画效果。使用方法animationWithKeyPath:对 CABasicAnimation进行实例化，并指定Layer的属性作为关键路径进行注册。例如： 1CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;]; 相关属性和声明属性 | 说明—|—duration | 动画时长repeatCount | 重复次数。不停重复设置为 HUGE_VALFbeginTime | 指定动画开始的时间。从开始延迟几秒的话，设置为[CACurren|tMediaTime() + 秒数] 的方式timingFunction | 动画的速度变化autoreverses | 动画结束时是否执行逆动画fromValue | 起始值toValue | 结束值byValue | 结束值（相对值） 一些常用的animationWithKeyPath值 值 说明 使用形式 transform.scale 比例转化 @(0.8) transform.scale.x 宽的比例 @(0.8) transform.scale.y 高的比例 @(0.8) transform.rotation.x 围绕x轴旋转 @(M_PI) transform.rotation.y 围绕y轴旋转 @(M_PI) transform.rotation.z 围绕z轴旋转 @(M_PI) cornerRadius 圆角的设置 @(50) backgroundColor 背景颜色的变化 (id)[UIColor purpleColor].CGColor bounds 大小，中心不变 [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 200)]; position 位置(中心点的改变) [NSValue valueWithCGPoint:CGPointMake(300, 300)]; contents 内容，比如UIImageView的图片 imageAnima.toValue = (id)[UIImage imageNamed:@”to”].CGImage; opacity 透明度 @(0.7) contentsRect.size.width 横向拉伸缩放 @(0.4)最好是0~1之间的 2.CABasicAnimation的使用示例 2.1.移动动画 123456CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;position&quot;];anima.fromValue = [NSValue valueWithCGPoint:CGPointMake(0, SCREEN_HEIGHT/2-75)];anima.toValue = [NSValue valueWithCGPoint:CGPointMake(SCREEN_WIDTH, SCREEN_HEIGHT/2-75)];anima.duration = 1.0f;anima.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn];[_demoView.layer addAnimation:anima forKey:@&quot;positionAnimation&quot;]; 2.2.透明度动画 12345CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];anima.fromValue = [NSNumber numberWithFloat:1.0f];anima.toValue = [NSNumber numberWithFloat:0.2f];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;opacityAniamtion&quot;]; 2.3.缩放动画 123456789CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;bounds&quot;];anima.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, 200, 100)];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;];// CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];//同上// anima.toValue = [NSNumber numberWithFloat:2.0f];// anima.duration = 1.0f;// [_demoView.layer addAnimation:anima forKey:@&quot;scaleAnimation&quot;]; 2.4.旋转动画 1234567891011CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];//绕着z轴为矢量，进行旋转(@&quot;transform.rotation.z&quot;==@@&quot;transform.rotation&quot;)anima.toValue = [NSNumber numberWithFloat:M_PI];anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;rotateAnimation&quot;];// //valueWithCATransform3D作用与layer// CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];// anima.toValue = [NSValue valueWithCATransform3D:CATransform3DMakeRotation(M_PI, 0, 0, 1)];//绕着矢量（x,y,z）旋转// anima.duration = 1.0f;// //anima.repeatCount = MAXFLOAT;// [_demoView.layer addAnimation:anima forKey:@&quot;rotateAnimation&quot;]; 2.5.背景色动画 1234CABasicAnimation *anima = [CABasicAnimation animationWithKeyPath:@&quot;backgroundColor&quot;];anima.toValue =(id) [UIColor greenColor].CGColor;anima.duration = 1.0f;[_demoView.layer addAnimation:anima forKey:@&quot;backgroundAnimation&quot;];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>CABasicAnimation</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block引用计数问题]]></title>
    <url>%2F2017%2F12%2F26%2F20171226-Block%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在学习block，在网上看到一个关于block和引用计数的问题:Block 捕获对象类型的变量时的问题123456789typedef void(^Block)();Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数%d&quot;, _objc_rootRetainCount(person));Block block = ^&#123; perons.name = @&quot;Nature&quot;; NSLog(@&quot;Block中person的引用计数%d&quot;, _objc_rootRetainCount(person));&#125;;block();NSLog(@&quot;Block后person的引用计数%d&quot;, _objc_rootRetainCount(person)); 在ARC下运行结果为： 123Block前person的引用计数为1Block中person的引用计数为3Block后person的引用计数为3 为什么block截获person变量后，引用计数会+2？接下来修改了代码，输出person的地址信息 12345678typedef void(^Block)(void);Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));Block block =^&#123; NSLog(@&quot;Block中person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));&#125;;block();NSLog(@&quot;Block后person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person)); 我在MRC 下运行代码，结果为：123Block前person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff628 -0x100547c20Block中person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff618 -0x100547c20Block后person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff628 -0x100547c20 其中 Person: 0x100547c20 为 person 对象信息0x7ffeefbff628 0x7ffeefbff618 为栈上指针，存放的数据是地址0x100547c200x100547c20 为堆上存放person的地址。 从MRC运行结果可以看出 MRC 下，block 内引用person 只复制了一个指针。 我多次运行 发现两个栈指针的差值是固定的，一直都是0x10（不太了解为什么差值一直一样，中间的地址存放的是什么数据）。接下来我在ARC下尝试着将person 的地址减去一个 0x10 , 将新地址的内容输出来。 12345678typedef void(^Block)(void);Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));Block block =^&#123; NSLog(@&quot;Block中person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));&#125;;block();NSLog(@&quot;Block后person的引用计数-%tu -%@ -%p -%p %p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person),(&amp;person-2),*(&amp;person-2)); 运行结果为：123Block前person的引用计数-1 -&lt;Person: 0x1004002b0&gt; -0x7ffeefbff620 -0x1004002b0Block中person的引用计数-3 -&lt;Person: 0x1004002b0&gt; -0x1007114c0 -0x1004002b0Block后person的引用计数-3 -&lt;Person: 0x1004002b0&gt; -0x7ffeefbff620 -0x1004002b0 0x7ffeefbff610 -0x1004002b0 我们发现在ARC下 栈指针 0x7ffeefbff610 和 0x7ffeefbff620 中的存放的数据都是person的地址 0x1004002b0。而在 堆地址0x1007114c0 也引用一份person。所以person的引用计数为3。 所以在ARC模式下，如果block 引用局部变量，先将变量地址复制到栈上，在从栈上复制到堆上。（不知道对不对啊）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString与TaggedPoint技术]]></title>
    <url>%2F2017%2F12%2F26%2F20171226-NSString%E4%B8%8ETaggedPoint%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1.问题在学习iOS中的NSString时，看到了掘金上的一篇文章 一个毫无道理的iOS问题1234567891011121314151617181920212223242526272829303132@interface ViewController ()@property (nonatomic, strong) NSString *string1;@property (nonatomic, assign) NSString *string2;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;1.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1&quot;]; self.string2 = self.string1; self.string1 = nil; NSLog(@&quot;string2 = %@&quot;,self.string2); NSLog(@&quot;2.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1234&quot;]; self.string2 = self.string1; self.string1 = nil; NSLog(@&quot;string2 = %@&quot;,self.string2);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 提问：第16行和第22行的执行结果分别是什么？测试后发现这段代码的问题是这样的:1.第16行执行后并不会崩溃，第22行执行后会崩溃2.只有字符串的内容长度超过10字节才会奔溃崩溃 2.解释我们修改代码查看两种情况下string1和string2的指针地址已经指针所存储的数据。 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;1.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;SSS&quot;]; self.string2 = self.string1; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); self.string1 = nil; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); NSLog(@&quot;string2 = %@&quot;,self.string2); NSLog(@&quot;\n\n&quot;); NSLog(@&quot;2.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1234&quot;]; self.string2 = self.string1; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); self.string1 = nil; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); NSLog(@&quot;string2 = %@&quot;,self.string2);&#125; 运行时第22行出现异常，我们先看一下第一种情况的打印信息。 1234561.-------string1 = 0xa000000005353533 0x15dd39540 SSS NSTaggedPointerStringstring2 = 0xa000000005353533 0x15dd39548 SSS NSTaggedPointerStringstring1 = 0x0 0x15dd39540 (null) (null)string2 = 0xa000000005353533 0x15dd39548 SSS NSTaggedPointerStringstring2 = SSS 可以看出0x15dd39540和0x15dd39548是两个堆指针，指针存储的数据是0xa000000005353533，可以看出0xa000000005353533不是一个有效地址，这是因为iOS使用了TaggedPoint技术，此时“SSS”这个字符串并不是存储在堆上，而是存储在self.string这个指针里面，self.string2=self.string1，完全就是一个赋值操作，不存在指向堆内存的问题，所以不会出现异常。关于TaggedPoint的详细介绍，给大家推荐一篇博客：深入理解Tagged Pointer 接下来我们看一下第二种情况的打印信息。 12342.-------string1 = 0x15de0f460 0x15dd39540 string1234 __NSCFStringstring2 = 0x15de0f460 0x15dd39548 string1234 __NSCFStringstring1 = 0x0 0x15dd39540 (null) (null) 从运行结果可以看出，0x15dd39540和0x15dd39548是两个堆指针，里面存的数据都是0x15de0f460，也是一个有效的堆地址，在self.string1=nil之后，0x15dd39540指向的内存区0x15de0f460已经被释放，再用self.string2来访问，0x15dd39548所执向的0x15de0f460已经不存在了，是一个野指针了，所以会野指针crash。 3.参考博客http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSString</tag>
        <tag>TaggedPoint</tag>
      </tags>
  </entry>
</search>
