<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Block引用计数问题]]></title>
    <url>%2F2017%2F12%2F26%2F20171226-block%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在学习block，在网上看到一个关于block和引用计数的问题:Block 捕获对象类型的变量时的问题123456789typedef void(^Block)();Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数%d&quot;, _objc_rootRetainCount(person));Block block = ^&#123; perons.name = @&quot;Nature&quot;; NSLog(@&quot;Block中person的引用计数%d&quot;, _objc_rootRetainCount(person));&#125;;block();NSLog(@&quot;Block后person的引用计数%d&quot;, _objc_rootRetainCount(person)); 在ARC下运行结果为： 123Block前person的引用计数为1Block中person的引用计数为3Block后person的引用计数为3 为什么block截获person变量后，引用计数会+2？接下来修改了代码，输出person的地址信息 12345678typedef void(^Block)(void);Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));Block block =^&#123; NSLog(@&quot;Block中person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));&#125;;block();NSLog(@&quot;Block后person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person)); 我在MRC 下运行代码，结果为：123Block前person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff628 -0x100547c20Block中person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff618 -0x100547c20Block后person的引用计数-1 -&lt;Person: 0x100547c20&gt; -0x7ffeefbff628 -0x100547c20 其中 Person: 0x100547c20 为 person 对象信息0x7ffeefbff628 0x7ffeefbff618 为栈上指针，存放的数据是地址0x100547c200x100547c20 为堆上存放person的地址。 从MRC运行结果可以看出 MRC 下，block 内引用person 只复制了一个指针。 我多次运行 发现两个栈指针的差值是固定的，一直都是0x10（不太了解为什么差值一直一样，中间的地址存放的是什么数据）。接下来我在ARC下尝试着将person 的地址减去一个 0x10 , 将新地址的内容输出来。 12345678typedef void(^Block)(void);Person *person = [[Person alloc] init];NSLog(@&quot;Block前person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));Block block =^&#123; NSLog(@&quot;Block中person的引用计数-%tu -%@ -%p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person));&#125;;block();NSLog(@&quot;Block后person的引用计数-%tu -%@ -%p -%p %p -%p&quot;, CFGetRetainCount((__bridge CFTypeRef)(person)),person,&amp;person,*(&amp;person),(&amp;person-2),*(&amp;person-2)); 运行结果为：123Block前person的引用计数-1 -&lt;Person: 0x1004002b0&gt; -0x7ffeefbff620 -0x1004002b0Block中person的引用计数-3 -&lt;Person: 0x1004002b0&gt; -0x1007114c0 -0x1004002b0Block后person的引用计数-3 -&lt;Person: 0x1004002b0&gt; -0x7ffeefbff620 -0x1004002b0 0x7ffeefbff610 -0x1004002b0 我们发现在ARC下 栈指针 0x7ffeefbff610 和 0x7ffeefbff620 中的存放的数据都是person的地址 0x1004002b0。而在 堆地址0x1007114c0 也引用一份person。所以person的引用计数为3。 所以在ARC模式下，如果block 引用局部变量，先将变量地址复制到栈上，在从栈上复制到堆上。（不知道对不对啊）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSString与TaggedPoint技术]]></title>
    <url>%2F2017%2F12%2F26%2F20171226-NSString%E4%B8%8ETaggedPoint%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[在学习iOS中的NSString时，看到了掘金上的一篇文章 一个毫无道理的iOS问题1234567891011121314151617181920212223242526272829303132@interface ViewController ()@property (nonatomic, strong) NSString *string1;@property (nonatomic, assign) NSString *string2;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;1.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1&quot;]; self.string2 = self.string1; self.string1 = nil; NSLog(@&quot;string2 = %@&quot;,self.string2); NSLog(@&quot;2.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1234&quot;]; self.string2 = self.string1; self.string1 = nil; NSLog(@&quot;string2 = %@&quot;,self.string2);&#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;@end 提问：第16行和第22行的执行结果分别是什么？测试后发现这段代码的问题是这样的： 第16行执行后并不会崩溃，第22行执行后会崩溃 只有字符串的内容长度超过10字节才会奔溃崩溃2.解释我们修改代码查看两种情况下string1和string2的指针地址已经指针所存储的数据。 123456789101112131415161718192021222324- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@&quot;1.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;SSS&quot;]; self.string2 = self.string1; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); self.string1 = nil; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); NSLog(@&quot;string2 = %@&quot;,self.string2); NSLog(@&quot;\n\n&quot;); NSLog(@&quot;2.-------&quot;); self.string1 = [[NSString alloc] initWithUTF8String:&quot;string1234&quot;]; self.string2 = self.string1; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); self.string1 = nil; NSLog(@&quot;string1 = %p %p %@ %@&quot;,_string1,&amp;_string1,_string1,[_string1 class]); NSLog(@&quot;string2 = %p %p %@ %@&quot;,_string2,&amp;_string2,_string2,[_string2 class]); NSLog(@&quot;string2 = %@&quot;,self.string2);&#125; 运行时第行出现异常，我们先看一下第一种情况的打印信息。 1234561.-------string1 = 0xa000000005353533 0x15dd39540 SSS NSTaggedPointerStringstring2 = 0xa000000005353533 0x15dd39548 SSS NSTaggedPointerStringstring1 = 0x0 0x15dd39540 (null) (null)string2 = 0xa000000005353533 0x15dd39548 SSS NSTaggedPointerStringstring2 = SSS 可以看出0x15dd39540和0x15dd39548是两个堆指针，指针存储的数据是0xa000000005353533，可以看出0xa000000005353533不是一个有效地址，这是因为iOS使用了TaggedPoint技术，此时“SSS”这个字符串并不是存储在堆上，而是存储在self.string这个指针里面，self.string2=self.string1，完全就是一个赋值操作，不存在指向堆内存的问题，所以不会出现异常。关于TaggedPoint的详细介绍，给大家推荐一篇博客：深入理解Tagged Pointer 接下来我们看一下第二种情况的打印信息。 12342.-------string1 = 0x15de0f460 0x15dd39540 string1234 __NSCFStringstring2 = 0x15de0f460 0x15dd39548 string1234 __NSCFStringstring1 = 0x0 0x15dd39540 (null) (null) 从运行结果可以看出，0x15dd39540和0x15dd39548是两个堆指针，里面存的数据都是0x15de0f460，也是一个有效的堆地址，在self.string1=nil之后，0x15dd39540指向的内存区0x15de0f460已经被释放，再用self.string2来访问，0x15dd39548所执向的0x15de0f460已经不存在了，是一个野指针了，所以会野指针crash。 3.参考博客http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>NSString TaggedPoint</tag>
      </tags>
  </entry>
</search>
